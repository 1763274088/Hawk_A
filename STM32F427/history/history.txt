


//		GPIO_ResetBits(GPIOE,GPIO_Pin_12);
//	printf("Temp is %d,%d,%d,%d,%d,%d\r\n",MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C1_SENS,MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C2_OFF,
//		MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C3_TCS,MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C4_TCO,
//		MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C5_TREF,MS5611_PROM_DATA_SHARED.MS5611_prom_data.MS5611_C6_TEMPSENS);
//		printf("Temp is %d,%d\r\n",MS5611_NORMAL_DATA_SHARED.MS5611_normal_data.D1_Pressure,MS5611_NORMAL_DATA_SHARED.MS5611_normal_data.D2_Temperature);
//		delay_ms(500);


//***************************************2015年12月16日
//		TIM3_Int_Init(50-1,9000-1);	//定时器时钟84M，分频系数8400，所以84M/8400=10Khz的计数频率，计数5000次为500ms  



//***************************************2015年12月18日
//通过串口打印SD卡相关信息
void show_sdcard_info(void)
{
	switch(SDCardInfo.CardType)
	{
		case SDIO_STD_CAPACITY_SD_CARD_V1_1:printf("Card Type:SDSC V1.1\r\n");break;
		case SDIO_STD_CAPACITY_SD_CARD_V2_0:printf("Card Type:SDSC V2.0\r\n");break;
		case SDIO_HIGH_CAPACITY_SD_CARD:printf("Card Type:SDHC V2.0\r\n");break;
		case SDIO_MULTIMEDIA_CARD:printf("Card Type:MMC Card\r\n");break;
	}	
  	printf("Card ManufacturerID:%d\r\n",SDCardInfo.SD_cid.ManufacturerID);	//制造商ID
 	printf("Card RCA:%d\r\n",SDCardInfo.RCA);								//卡相对地址
	printf("Card Capacity:%d MB\r\n",(u32)(SDCardInfo.CardCapacity>>20));	//显示容量
 	printf("Card BlockSize:%d\r\n\r\n",SDCardInfo.CardBlockSize);			//显示块大小
}


//***************************************2015年12月21日


		u32 total,free;
		int i=0;
		int a=1;
		u8 res=0;	


		my_mem_init(SRAMIN);		//初始化内部内存池 
		my_mem_init(SRAMCCM);		//初始化CCM内存池

 	while(SD_Init())//检测不到SD卡
	{
		GPIO_SetBits(GPIOE,GPIO_Pin_12 );
		delay_ms(500);					
		GPIO_ResetBits(GPIOE,GPIO_Pin_12);		
		delay_ms(500);

	}
	show_sdcard_info();	//打印SD卡相关信息
	
		exfuns_init();							//为fatfs相关变量申请内存				 
  	f_mount(fs[0],"0:",1); 					//挂载SD卡 
		res=f_mount(fs[1],"1:",1); 				//挂载FLASH.	
		if(res==0X0D)//FLASH磁盘,FAT文件系统错误,重新格式化FLASH
		{
		printf("Flash Disk Formatting...\r\n");	//格式化FLASH
		res=f_mkfs("1:",1,4096);//格式化FLASH,1,盘符;1,不需要引导区,8个扇区为1个簇
		if(res==0)
		{
			f_setlabel((const TCHAR *)"1:HUANGZHIBIN");	//设置Flash磁盘的名字为：HUANGZHIBIN
			printf("Flash Disk Format Finish\r\n");		//格式化完成	
		}
		else 
		printf("Flash Disk Format Error \r\n");		//格式化失败	
		delay_ms(1000);
		}				
	
	while(exf_getfree("0",&total,&free))	//得到SD卡的总容量和剩余容量
	{
		printf("SD Card Fatfs Error!\r\n");		
		delay_ms(200);		  
		delay_ms(200);
		LED0=!LED0;//DS0闪烁
	}	
	
		printf("FATFS OK!\r\n");		
		printf("SD Total Size:  %d   MB\r\n",total>>10);	
		printf("SD  Free Size:  %d   MB\r\n",free>>10);		
		



//***************************************2015年12月23日
今天，发现了一个很好地处理SPI超时处理的方法，在SPI1_ReadWriteByte函数里面
只要加上一个计时的标志位，用来检测发送数据之后，用了多久时间，来判断是否超时，
超时之后，可以死循环或者通过串口打印消息或者用LED来显示。
如：这是ST的官方例子

static uint8_t L3GD20_SendByte(uint8_t byte)
{
  /* Loop while DR register in not empty */
  L3GD20Timeout = L3GD20_FLAG_TIMEOUT;
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_TXE) == RESET)
  {
    if((L3GD20Timeout--) == 0) return L3GD20_TIMEOUT_UserCallback();
  }
  
  /* Send a Byte through the SPI peripheral */
  SPI_SendData8(L3GD20_SPI, byte);
  
  /* Wait to receive a Byte */
  L3GD20Timeout = L3GD20_FLAG_TIMEOUT;
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
  {
    if((L3GD20Timeout--) == 0) return L3GD20_TIMEOUT_UserCallback();
  }
  
  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
}

//***************************************2015年12月26日
今天编写调试完FM25V01的驱动，函数测试完毕，要注意的问题有几点：1、SPI的外设时钟一定要写对，SPI1和
SPI2的外设时钟是不一样的，设置错误将会导致TX寄存器不为空，一直卡死；2、在写的时候，一定要单独发送
WREN，拉低CS，发送WREN，拉高，在发送地址和内容才行；3、支持连读和连写！


uint8_t write_buffer[10]={00,11,22,33,44,55,66,77,88,99};
uint8_t read_buffer[10]={0};

		SPI2_Init();
		FM25V01_CS_Init();		
		FM25V01_Read_Device_ID();	
		FM25V01_multiple_Write_Memory(0x0030,write_buffer,10);
		delay_ms(500);
		FM25V01_Fast_multiple_Read_Memory(0x0030,read_buffer,10);
	
//		FM25V01_Write_Memory(0x0020,100);
//		delay_ms(500);
//		table=FM25V01_Read_Memory(0x0020);


  	printf("Data is %d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",read_buffer[0],read_buffer[1],read_buffer[2],read_buffer[3],read_buffer[4],read_buffer[5],read_buffer[6],read_buffer[7],read_buffer[8],read_buffer[9]);
	
//		printf("ID is %d,%d,%d,%d,%d,%d,%d,%d,%d\r\n",FM25V01_ID.FM25V01_Product_ID.Continuation_code_1,
//		FM25V01_ID.FM25V01_Product_ID.Continuation_code_2,
//		FM25V01_ID.FM25V01_Product_ID.Continuation_code_3,
//		FM25V01_ID.FM25V01_Product_ID.Continuation_code_4,
//		FM25V01_ID.FM25V01_Product_ID.Continuation_code_5,
//		FM25V01_ID.FM25V01_Product_ID.Continuation_code_6,
//		FM25V01_ID.FM25V01_Product_ID.JEDEC_assigned_Ramtron,
//		FM25V01_ID.FM25V01_Product_ID.Device_ID_1,
//		FM25V01_ID.FM25V01_Product_ID.Device_ID_2);
		
		
		
		
